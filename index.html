function UserDiv() {
const Sidebar = ({ isOpen, setIsOpen, currentPage, setCurrentPage }) => {
  const navigationItems = [
    { name: 'MetroModoro', label: 'MetroModoro' },
    { name: 'QID Extractor', label: 'QID Extractor' },
  ];

  return (
    <div className={`bg-gray-800 shadow-xl h-full fixed left-0 top-0 ${isOpen ? 'w-64' : 'w-16'} z-10 transition-width duration-300 ease-in-out`}>
      <div className="h-full">
        <div className="flex items-center justify-between bg-gray-900 p-4 h-16">
          <h2 className={`text-white text-lg ${!isOpen && 'hidden'}`}>Menu</h2>
          <button onClick={() => setIsOpen(!isOpen)} aria-expanded={isOpen} aria-label="Toggle Sidebar" className="p-2">
            <svg className="h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d={isOpen ? "M6 18L18 6M6 6l12 12" : "M4 6h16M4 12h16m-7 6h7"} />
            </svg>
          </button>
        </div>
        <nav className="text-white text-base font-semibold">
          {navigationItems.map((item) => (
            <a key={item.name} href="#" className={`flex items-center text-white py-4 pl-6 nav-item ${currentPage === item.name ? 'bg-gray-700' : ''}`} onClick={(e) => { e.preventDefault(); setCurrentPage(item.name); }}>
              <span className={`${!isOpen && 'hidden'}`}>{item.label}</span>
            </a>
          ))}
        </nav>
      </div>
    </div>
  );
};

  const [isOpen, setIsOpen] = React.useState(false);
  const [currentPage, setCurrentPage] = React.useState('MetroModoro');
  
// MetroModoro component code
  const MetroModoro = () => {
    const localStorageKeys = {
    sessionTime: "sessionTime",
    shortBreak: "shortBreak", // Updated to match naming convention
    longBreakTime: "longBreakTime",
    sessionsBeforeLongBreak: "sessionsBeforeLongBreak",
    enableLongBreak: "enableLongBreak",
    audioEnabled: "audioEnabled",
    bpm: "bpm",
    isDarkMode: "isDarkMode",
  };
  const loadSetting = (key, defaultValue) => {
    const savedValue = localStorage.getItem(key);
    // If the setting is numeric, parse it, otherwise return directly for booleans and strings
    return savedValue !== null
      ? isNaN(parseInt(savedValue, 10))
        ? savedValue === "true"
        : parseInt(savedValue, 10)
      : defaultValue;
  };
  const saveSetting = (key, value) => {
    localStorage.setItem(key, value);
  };
  const [sessionTime, setSessionTime] = React.useState(
    loadSetting(localStorageKeys.sessionTime, 16 * 60)
  );
  const [shortBreak, setShortBreak] = React.useState(
    loadSetting(localStorageKeys.shortBreak, 6 * 60)
  );
  const [longBreakTime, setLongBreakTime] = React.useState(
    loadSetting(localStorageKeys.longBreakTime, 20 * 60)
  );
  const [sessionsBeforeLongBreak, setSessionsBeforeLongBreak] = React.useState(
    loadSetting(localStorageKeys.sessionsBeforeLongBreak, 3)
  );

  const [currentSessionCount, setCurrentSessionCount] = React.useState(0);
  const [enableLongBreak, setEnableLongBreak] = React.useState(
    loadSetting(localStorageKeys.enableLongBreak, true)
  );

  const [audioEnabled, setAudioEnabled] = React.useState(
    loadSetting(localStorageKeys.audioEnabled, true)
  );

  const [timeLeft, setTimeLeft] = React.useState(sessionTime); // This will be updated based on endTime
  const [isSession, setIsSession] = React.useState(true);
  const [isRunning, setIsRunning] = React.useState(false);
  const [bpm, setBpm] = React.useState(loadSetting(localStorageKeys.bpm, 5));
  const [isDarkMode, setIsDarkMode] = React.useState(
    localStorage.getItem(localStorageKeys.isDarkMode) === "true"
  );
  const [isFullScreen, setIsFullScreen] = React.useState(false);
  const [showTimerOnly, setShowTimerOnly] = React.useState(false);
  const [isLongBreak, setIsLongBreak] = React.useState(false);
  const handleInputFocus = (e) => {
    e.target.value = "";
  };

  const handleInputBlur = (setter, defaultValue) => (e) => {
    if (e.target.value.trim() === "") {
      setter(defaultValue);
    } else {
      setter(Math.max(1, parseInt(e.target.value, 10)) * 60);
    }
  };
  const [endTime, setEndTime] = React.useState(() => {
    const savedEndTime = localStorage.getItem("endTime");
    return savedEndTime ? parseInt(savedEndTime, 10) : null;
  });
  const containerRef = React.useRef(null);
  const audioRef = React.useRef(null);
  const endSessionSoundRef = React.useRef(null);
  const metronomeIntervalRef = React.useRef(null);

  React.useEffect(() => {
    audioRef.current = new Audio(
      "https://cdn.freesound.org/previews/723/723925_15697841-lq.mp3"
    );
    endSessionSoundRef.current = new Audio(
      "https://cdn.freesound.org/previews/160/160513_71257-lq.mp3"
    );
  }, []);

  React.useEffect(() => {
    if (endTime) {
      const now = Date.now();
      const remainingTime = Math.max(endTime - now, 0) / 1000;
      setTimeLeft(remainingTime);
      if (remainingTime > 0) {
        setIsRunning(true);
      }
    }
  }, [endTime]);

  React.useEffect(() => {
    if (endTime) {
      localStorage.setItem("endTime", endTime.toString());
    } else {
      localStorage.removeItem("endTime");
    }
  }, [endTime]);

  React.useEffect(() => {
    saveSetting(localStorageKeys.sessionTime, sessionTime);
  }, [sessionTime]);
  React.useEffect(() => {
    saveSetting(localStorageKeys.shortBreak, shortBreak);
  }, [shortBreak]); // Ensure using shortBreak
  React.useEffect(() => {
    saveSetting(localStorageKeys.longBreakTime, longBreakTime);
  }, [longBreakTime]);
  React.useEffect(() => {
    saveSetting(
      localStorageKeys.sessionsBeforeLongBreak,
      sessionsBeforeLongBreak
    );
  }, [sessionsBeforeLongBreak]);
  React.useEffect(() => {
    localStorage.setItem(
      localStorageKeys.enableLongBreak,
      enableLongBreak.toString()
    );
    localStorage.setItem(
      localStorageKeys.audioEnabled,
      audioEnabled.toString()
    );
  }, [enableLongBreak, audioEnabled]);
  console.log("Enable Long Break:", enableLongBreak);
  console.log("Audio Enabled:", audioEnabled);

  React.useEffect(() => {
    saveSetting(localStorageKeys.bpm, bpm);
  }, [bpm]);
  React.useEffect(() => {
    localStorage.setItem(localStorageKeys.isDarkMode, isDarkMode);
  }, [isDarkMode]);

  React.useEffect(() => {
    let interval = null;

    // Function to update time left based on the current endTime

    const updateRemainingTime = () => {
      const now = Date.now();
      // Use Math.floor to ensure timeLeft is a whole number
      const remainingTime = Math.max(Math.floor((endTime - now) / 1000), 0);
      setTimeLeft(remainingTime);

      if (remainingTime === 0) {
        clearInterval(interval);
        setIsRunning(false);
        // Here you would also handle the transition logic from session to break or vice versa
        handleSessionTransition();
      }
    };

    if (isRunning && endTime) {
      // Initialize the countdown or refresh it based on the latest endTime
      updateRemainingTime();
      interval = setInterval(updateRemainingTime, 1000);
    } else if (!isRunning) {
      clearInterval(interval);
    }

    // Cleanup on component unmount or before re-running this effect
    return () => clearInterval(interval);
  }, [isRunning, endTime]); // Only re-run the effect if isRunning or endTime changes

  // This new function manages transitions between work sessions and breaks
  const handleSessionTransition = () => {
    const newSessionCount = isSession
      ? currentSessionCount + 1
      : currentSessionCount;
    setCurrentSessionCount(newSessionCount);
    let nextTime;
    if (isSession) {
      if (enableLongBreak && newSessionCount % sessionsBeforeLongBreak === 0) {
        nextTime = longBreakTime;
        setIsLongBreak(true);
      } else {
        nextTime = shortBreak;
        setIsLongBreak(false);
      }
    } else {
      nextTime = sessionTime;
      setIsLongBreak(false);
    }
    // Set the next session or break to start automatically
    const now = Date.now();
    const newEndTime = now + nextTime * 1000;
    setEndTime(newEndTime);
    setIsSession(!isSession);
    setIsRunning(true);
  };
  React.useEffect(() => {
    if (timeLeft === 0) {
      handleSessionTransition();
    }
  }, [timeLeft]);
  React.useEffect(() => {
    if (timeLeft !== 0) return;
    if (audioEnabled) {
      endSessionSoundRef.current.play();
    }
    const newSessionCount = isSession
      ? currentSessionCount + 1
      : currentSessionCount;
    if (isSession) {
      if (enableLongBreak && newSessionCount % sessionsBeforeLongBreak === 0) {
        setTimeLeft(longBreakTime);
        setIsLongBreak(true);
      } else {
        setTimeLeft(shortBreak);
        setIsLongBreak(false);
      }
      setIsSession(false);
    } else {
      setTimeLeft(sessionTime);
      setIsSession(true);
      setIsLongBreak(false);
    }
    setCurrentSessionCount(newSessionCount);
  }, [
    timeLeft,
    isSession,
    sessionTime,
    shortBreak,
    longBreakTime,
    enableLongBreak,
    currentSessionCount,
    sessionsBeforeLongBreak,
    audioEnabled,
  ]);

  React.useEffect(() => {
    if (isSession && isRunning && audioEnabled) {
      clearInterval(metronomeIntervalRef.current);
      // Calculate the delay for the first metronome tick based on the current timeLeft
      const initialDelay = (timeLeft * 1000) % ((60 / bpm) * 1000);
      // Play the metronome sound after the initial delay
      metronomeIntervalRef.current = setTimeout(() => {
        audioRef.current.play();
        // After the initial delay, continue with the regular interval
        metronomeIntervalRef.current = setInterval(() => {
          audioRef.current.play();
        }, (60 / bpm) * 1000);
      }, initialDelay);
    } else {
      clearInterval(metronomeIntervalRef.current);
    }
    // Cleanup on component unmount or before re-running this effect
    return () => {
      clearInterval(metronomeIntervalRef.current);
      clearTimeout(metronomeIntervalRef.current);
    };
  }, [isSession, bpm, isRunning, audioEnabled, timeLeft]);

  React.useEffect(() => {
    setTimeLeft(
      isSession ? sessionTime : isLongBreak ? longBreakTime : shortBreak
    );
  }, [sessionTime, shortBreak, longBreakTime, isSession, isLongBreak]);

  const handleStart = () => {
    const now = Date.now();
    const newEndTime = now + timeLeft * 1000;
    setEndTime(newEndTime);
    setIsRunning(true);
  };
  const handlePause = () => {
    setIsRunning(false);
    setEndTime(null);
  };
  const handleReset = () => {
    setIsRunning(false);
    setTimeLeft(
      isSession ? sessionTime : isLongBreak ? longBreakTime : shortBreak
    );
    setEndTime(null);
    setCurrentSessionCount(0);
  };

  const toggleStartPause = () => {
    if (!isRunning) {
      // Starting or resuming the timer
      const now = Date.now();
      const newEndTime = now + timeLeft * 1000;
      setEndTime(newEndTime); // Update endTime for the countdown
    } else {
      // Pausing the timer
      const now = Date.now();
      const remainingTime = Math.max(endTime - now, 0);
      // Adjust the calculation for timeLeft, rounding down to remove the extra second
      setTimeLeft(Math.floor(remainingTime / 1000)); // Update timeLeft to more accurately reflect the remaining time
    }
    setIsRunning(!isRunning); // Toggle the running state
  };

  const formatTime = (time) => {
    const minutes = Math.floor(time / 60);
    const seconds = time % 60;
    return `${minutes.toString().padStart(2, "0")}:${seconds
      .toString()
      .padStart(2, "0")}`;
  };

  const modeStyles = {
    backgroundColor: isDarkMode ? "#121212" : "#FFF",
    color: isDarkMode ? "#FFF" : "#333",
    transition: "background-color 0.3s ease-in-out, color 0.3s ease-in-out",
  };

  const buttonStyle = isDarkMode
    ? "bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded transition-colors duration-300"
    : "bg-blue-500 hover:bg-blue-400 text-white font-bold py-2 px-4 rounded transition-colors duration-300";

  const handleFullScreen = () => {
    if (!document.fullscreenElement) {
      containerRef.current.requestFullscreen().catch((e) => {
        console.error(`Fullscreen mode failed: ${e.message}`);
      });
      setIsFullScreen(true);
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
      setIsFullScreen(false);
    }
  };

  return (
    <div
      ref={containerRef}
      style={{
        ...modeStyles,
        width: "100vw",
        height: "100vh",
        border: "80px solid transparent",
      }} // Added border style
      className="flex flex-col items-center justify-center p-4 rounded-lg shadow-lg"
    >
      {/* Control buttons (Full Screen, Timer Only, Dark Mode, etc.) */}
      {!showTimerOnly && (
        <>
          <button
            onClick={handleFullScreen} // This line is updated
            className={`${buttonStyle} absolute top-10 right-5 m-4`}
          >
            {isFullScreen ? "Exit Full Screen" : "Full Screen"}
          </button>
          <button
            onClick={() => setShowTimerOnly(!showTimerOnly)}
            className={`${buttonStyle} absolute top-10 left-12 m-4`}
          >
            Timer Only
          </button>
          <button
            onClick={() => setIsDarkMode(!isDarkMode)}
            className={`${buttonStyle} mb-4`}
          >
            {isDarkMode ? "Toggle Light Mode" : "Toggle Dark Mode"}
          </button>
        </>
      )}
      {showTimerOnly && (
        <button
          onClick={() => setShowTimerOnly(!showTimerOnly)}
          className={`${buttonStyle} absolute top-0 left-0 m-4`}
        >
          Show Controls
        </button>
      )}
      <h2
        className={`text-2xl font-semibold mb-4 ${
          showTimerOnly ? "absolute top-16 left-0 right-0 text-center" : ""
        }`}
        style={{ zIndex: showTimerOnly ? 1 : "auto" }} // Ensure it's visible above or appropriately positioned
      >
        {isSession
          ? "Work Session"
          : isLongBreak
          ? "Long Break"
          : "Short Break"}
      </h2>
      <div
        className="font-bold mb-4 p-4 rounded-lg shadow"
        style={{ fontSize: showTimerOnly ? "10rem" : "4rem", ...modeStyles }}
      >
        {formatTime(timeLeft)}
      </div>
      {showTimerOnly && (
        <div className="flex justify-center mt-4">
          <button
            onClick={toggleStartPause}
            className={`${buttonStyle}`}
            style={{ fontSize: "2rem" }} // Adjust the font size as needed
          >
            {isRunning ? " ||" : " â–¶"} {/* Pause and Start symbols */}
          </button>
        </div>
      )}
      {!showTimerOnly && (
        <div className="flex space-x-4 mb-4">
          <button onClick={handleStart} className={buttonStyle}>
            Start
          </button>
          <button onClick={handlePause} className={buttonStyle}>
            Pause
          </button>
          <button onClick={handleReset} className={buttonStyle}>
            Reset
          </button>
        </div>
      )}
      {!showTimerOnly && (
        <div className="flex flex-wrap items-center justify-center gap-4 mb-4">
          <label className="flex flex-col items-center">
            <span>Work Session (min):</span>
            <input
              type="number"
              value={Math.round(sessionTime / 60)}
              onChange={(e) => setSessionTime(Math.max(1, e.target.value) * 60)}
              onFocus={handleInputFocus}
              onBlur={() => handleInputBlur(setSessionTime, 16 * 60)}
              className="input input-bordered w-full max-w-xs"
              style={modeStyles}
            />
          </label>
          <label className="flex flex-col items-center">
            <span>Short Break (min):</span>
            <input
              type="number"
              value={Math.round(shortBreak / 60)}
              onChange={(e) => setShortBreak(Math.max(1, e.target.value) * 60)} // Corrected to use setShortBreak
              onFocus={handleInputFocus}
              onBlur={() => handleInputBlur(setShortBreak, 6 * 60)}
              className="input input-bordered w-full max-w-xs"
              style={modeStyles}
            />
          </label>
          <label className="flex flex-col items-center">
            <span>FlashCards by Min:</span>
            <input
              type="number"
              value={bpm}
              min="0.0001"
              max="1000"
              step="1"
              onChange={(e) => setBpm(Math.max(1, e.target.value))}
              onFocus={handleInputFocus}
              onBlur={() => handleInputBlur(setBpm, 5)}
              className="input input-bordered w-full max-w-xs"
              style={modeStyles}
            />
          </label>
          <div className="flex items-center">
            <input
              type="checkbox"
              checked={audioEnabled}
              onChange={(e) => setAudioEnabled(e.target.checked)}
            />
            <label htmlFor="audioCheckbox" className="ml-2">
              Enable Background Sound
            </label>
          </div>
          <label className="flex flex-col items-center">
            <span>Long Break (min):</span>
            <input
              type="number"
              value={Math.round(longBreakTime / 60)}
              onChange={(e) => {
                const newLongBreakTime =
                  Math.max(1, parseInt(e.target.value, 10)) * 60;
                setLongBreakTime(newLongBreakTime);
              }}
              onFocus={handleInputFocus}
              onBlur={() => handleInputBlur(setShortBreak, 20 * 60)}
              className="input input-bordered w-full max-w-xs"
              style={
                enableLongBreak ? modeStyles : { ...modeStyles, opacity: 0.5 }
              } // Conditional styling based on enableLongBreak
              disabled={!enableLongBreak}
            />
          </label>
          <label className="flex flex-col items-center">
            <span>Sessions Before Long Break:</span>
            <input
              type="number"
              value={sessionsBeforeLongBreak}
              onChange={(e) =>
                setSessionsBeforeLongBreak(Math.max(1, e.target.value))
              }
              onFocus={handleInputFocus}
              onBlur={() => handleInputBlur(setSessionsBeforeLongBreak, 3)}
              className="input input-bordered w-full max-w-xs"
              style={modeStyles}
              disabled={!enableLongBreak}
            />
          </label>
          <div className="flex items-center">
            <input
              type="checkbox"
              checked={enableLongBreak}
              onChange={(e) => setEnableLongBreak(e.target.checked)}
            />
            <label htmlFor="longBreakCheckbox" className="ml-2">
              Enable Long Break
            </label>
          </div>
        </div>
      )}
    </div>
  );
};
  // QID Extractor component placeholder
  const QIDExtractor = () => {
    const [inputText, setInputText] = React.useState('');
  const [showPopup, setShowPopup] = React.useState(false);
  const [qidData, setQidData] = React.useState([]);
  const [topWordsData, setTopWordsData] = React.useState([]);
  const [groupByTen, setGroupByTen] = React.useState(false);
  const [useComma, setUseComma] = React.useState(true);

  const findAllQIDs = (input) => {
  // Define both patterns to match the two different formats
  const pattern1 = /#AK_Step1_v\d+::#UWorld::(\d+)/g;
  const pattern2 = /#AK_Step1_v\d+::#UWorld::\d+-\d+::\d+-\d+::(\d+)/g;

  // Function to extract QIDs using a given pattern
  const extractQIDs = (pattern) => {
    const matches = [];
    let match;
    while ((match = pattern.exec(input)) !== null) {
      // Add the QID to matches if it's not already included
      if (match[1] && !matches.includes(match[1])) {
        matches.push(match[1]);
      }
    }
    return matches;
  };

  // Extract QIDs with both patterns
  const qidsFromPattern1 = extractQIDs(pattern1);
  const qidsFromPattern2 = extractQIDs(pattern2);

  // Combine and remove duplicates
  const allQIDs = [...new Set([...qidsFromPattern1, ...qidsFromPattern2])];
  return allQIDs;
};


  const getMeaningfulWords = (input) => {
    const stopwords = [
      'the', 'and', 'a', 'to', 'of', 'in', 'that', 'it', 'with', '#', '::',
      'ak_step1_v12', 'ak_updatetags', 'zanki', 'ankihub_imageready', 'ome_banner',
      'step1decks', 'step', 'decks', 'ak_original_decks', 'step_1', 'zanki_step_decks',
      'zanki_gi', 'physeo', 'temporary', 'imagefix', 'done',
      'b', 'c1', 'watch', 'associated', 'index', 'sketchy', 
      'video', 'other', 'highyield', 'firstaid',
      'by', 'bootcamp', 'text', 'div', 'i', 'u', 'tab', 'separator', 'html', 'true', 'tags', 'column', 'also', 'have', 'br', 'img', 'https', 'com', 'videos', 'href', 'jpg', 'app', 'school'
    ];

    // Split the input by new lines or another delimiter if your tags are structured differently
    const lines = input.split('\n');

    // Extract the last part of each tag after the "::" delimiter
    const meaningfulParts = lines.map(line => {
      const parts = line.split('::');
      return parts[parts.length - 1]; // Get the last part
    });

    // Convert to lowercase and match words as before, filtering out stopwords
    const words = meaningfulParts.join(' ').toLowerCase().match(/\b(\w+)\b/g).filter(word => !stopwords.includes(word));

    // Reduce to a frequency map as before
    return words.reduce((acc, word) => {
      acc[word] = (acc[word] || 0) + 1;
      return acc;
    }, {});
  };

  const topFrequentWords = (wordsMap, limit = 10) => {
    return Object.entries(wordsMap)
      .sort((a, b) => b[1] - a[1])
      .slice(0, limit)
      .map(([word, freq]) => ({ word, freq }));
  };

  const handleAnalyzeClick = () => {
    const qids = findAllQIDs(inputText);
    const wordMap = getMeaningfulWords(inputText); // Use full input text for word analysis
    const topWords = topFrequentWords(wordMap);

    setQidData(qids);
    setTopWordsData(topWords);
    setShowPopup(true); // Show popup with QIDs and top words
  };

  const toggleGroupByTen = () => setGroupByTen(!groupByTen);
  const toggleComma = () => setUseComma(!useComma);

  const formatQIDs = (qids) => {
    let separator = useComma ? ", " : " ";
    if (groupByTen) {
      const groupedQIDs = [];
      for (let i = 0; i < qids.length; i += 10) {
        groupedQIDs.push(qids.slice(i, i + 10).join(separator));
      }
      return groupedQIDs.join("\n\n");
    } else {
      return qids.join(separator);
    }
  };
  const [showTutorialPopup, setShowTutorialPopup] = React.useState(false);
  const toggleTutorialPopup = () => setShowTutorialPopup(!showTutorialPopup);

return (
  <div style={{
    fontFamily: 'Sans-serif',
    width: "100vw",
    height: "100vh",
    padding: "80px 0", // Adjusted to create space for the title within the flow
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    boxSizing: 'border-box',
  }}>
    <h1 style={{
      fontFamily: '"Helvetica Neue", Helvetica, Arial, sans-serif',
      fontSize: '5em',
      fontWeight: 'bold',
      margin: '20px 0', // Adjusted to push content below
      alignSelf: 'center', // Center the title within the flex container
    }}>
      UWorld QID Extractor
    </h1>
    <textarea
      style={{ 
        maxWidth: '800px', // Limit the maximum width
        width: 'calc(100% - 160px)', // Adjust for border padding, assuming container padding is meant to be kept
        padding: '10px',
        marginBottom: '20px',
        borderRadius: '8px',
        border: '1px solid #ccc',
      }}
      rows="6"
      placeholder="Enter Anki TAGS to analyze..."
      value={inputText}
      onChange={(e) => setInputText(e.target.value)}
    />
<div style={{
  position: 'absolute', // Position the container absolutely relative to its parent
  bottom: '20px', // 20px from the bottom
  right: '20px', // 20px from the right
  zIndex: 10, // Ensure it's above other elements if necessary
}}>
  <button
    style={{
      backgroundColor: '#007bff',
        color: 'white',
        padding: '10px 20px',
        border: 'none',
        borderRadius: '5px',
        cursor: 'pointer',
        maxWidth: '800px',
      cursor: 'pointer',
    }}
    onClick={toggleTutorialPopup} // Toggle the display of the tutorial popup
  >
    How to Use?
  </button>
</div>
    <button
      style={{
        backgroundColor: '#007bff',
        color: 'white',
        padding: '10px 20px',
        border: 'none',
        borderRadius: '5px',
        cursor: 'pointer',
        maxWidth: '800px', // Ensure buttons don't stretch beyond the text area's max width
      }}
      onClick={handleAnalyzeClick}
    >
      Analyze
    </button>
    {showPopup && (
      <div className="overlay" style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.75)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
      }}>
        <div className="popup" style={{
          backgroundColor: '#fff',
          display: 'flex',
          flexDirection: 'row',
          maxWidth: '800px', // Consistent with the textarea's max width
          width: '90vw', // Responsive width
          maxHeight: '80vh',
          borderRadius: '8px',
          boxShadow: '0 15px 35px rgba(0, 0, 0, 0.2)',
          padding: '20px',
          position: 'relative',
          overflow: 'auto',
          zIndex: 1050,
        }}>
          <div style={{ position: 'absolute', top: '10px', right: '10px' }}>
            <button onClick={() => setShowPopup(false)} style={{
              fontSize: '1.5em',
              border: 'none',
              background: 'none',
              cursor: 'pointer',
            }}>
              &times;
            </button>
          </div>
          <div style={{ flex: 3, marginRight: '20px', overflowY: 'auto', padding: '10px' }}>
            <h2 style={{ color: '#333', fontSize: '1.25em', fontWeight: '600', marginBottom: '0.2em' }}>UWorld QIDs:</h2>
            <div style={{ fontSize: '5em', color: '#555', fontWeight: '700', marginBottom: '0.2em' }}>
              {qidData.length}
            </div>
            <div style={{ marginBottom: '20px', display: 'flex', justifyContent: 'center', gap: '10px' }}>
  <button
    style={{ backgroundColor: '#007bff', color: 'white', padding: '10px 20px', border: 'none', borderRadius: '5px', cursor: 'pointer' }}
    onClick={toggleGroupByTen}
  >
    {groupByTen ? "Group All QIDs" : "Group QIDs by 10"}
  </button>
  <button
    style={{ backgroundColor: '#007bff', color: 'white', padding: '10px 20px', border: 'none', borderRadius: '5px', cursor: 'pointer' }}
    onClick={toggleComma}
  >
    {useComma ? "Use Space Separator" : "Use Comma Separator"}
  </button>
</div>
            <p style={{ fontFamily: 'monospace', lineHeight: '1.5', textAlign: 'center' }}>
              {formatQIDs(qidData)}
            </p>
          </div>
          <div style={{ flex: 2, overflowY: 'auto', padding: '10px' }}>
            <h2 style={{ color: '#333', fontSize: '1.25em', fontWeight: '600' }}>Top Frequent Words:</h2>
            <table style={{ width: '100%', marginTop: '10px' }}>
              <thead>
                <tr style={{ backgroundColor: '#f8f8f8', textAlign: 'left' }}>
                  <th style={{ padding: '10px 15px', borderBottom: '2px solid #eee' }}>Word</th>
                  <th style={{ padding: '10px 15px', borderBottom: '2px solid #eee' }}>Frequency</th>
                </tr>
              </thead>
              <tbody>
                {topWordsData.map(({ word, freq }) => (
                  <tr key={word}>
                    <td style={{ padding: '10px 15px', borderBottom: '1px solid #eee' }}>{word}</td>
                    <td style={{ padding: '10px 15px', borderBottom: '1px solid #eee' }}>{freq}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    )}
    {showTutorialPopup && (
  <div
    className="overlay"
    style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.75)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      zIndex: 1010,
    }}
  >
    <div
      className="tutorial-popup"
      style={{
        backgroundColor: '#fff',
        borderRadius: '8px',
        width: '60vw',
        maxHeight: '80vh',
        padding: '20px',
        position: 'relative',
        overflowY: 'auto',
      }}
    >
      <button
        onClick={() => setShowTutorialPopup(false)}
        style={{
          position: 'absolute',
          top: '10px',
          right: '10px',
          fontSize: '1.5em',
          border: 'none',
          background: 'none',
          cursor: 'pointer',
        }}
      >
        &times;
       </button>
      {/* Adjusted title */}
      <h2 style={{
        textAlign: 'center', // Center align the title
        fontWeight: 'bold', // Ensure the font weight is bold
        fontSize: '24px', // Optional: Adjust font size as needed
        marginBottom: '20px', // Optional: Adjust bottom margin for spacing
      }}>
        How to Extract Question IDs from Anki TAGs
      </h2>
      <p><strong>Getting Started with Anki:</strong></p>
      <ul>
        <li>Open the Anki desktop application.</li>
        <li>Navigate to 'Browse' to view your flashcards.</li>
        <li>Select your desired subject or deck from the sidebar.</li>
      </ul>
      <p><strong>Organizing Flashcards:</strong></p>
      <ul>
        <li>Select individual or multiple flashcards for analysis.</li>
        <li>Use keyboard shortcuts (Ctrl + A or Cmd + A) to select all visible cards.</li>
      </ul>
      <p><strong>Exporting Data:</strong></p>
      <ul>
        <li>Right-click a selected card and choose 'Export Notes'.</li>
        <li>Select 'Notes in Plain Text (.txt)' as the export format.</li>
        <li>Export your notes and save the file.</li>
      </ul>
      <p><strong>Extracting TAGs:</strong></p>
      <ul>
        <li>Open the exported text file to access your TAGs.</li>
        <li>Copy and paste the TAGs into the QID Extractor input.</li>
        <li>Click 'Analyze' to process the TAGs.</li>
      </ul>
      <p><strong>Additional Resources:</strong></p>
<div style={{
  display: 'flex', // Apply a flexbox layout
  flexDirection: 'row', // Arrange buttons in a row
  justifyContent: 'space-between', // Distribute space between buttons evenly
  flexWrap: 'wrap', // Allow buttons to wrap in small screens
  gap: '10px', // Add gap between items
  marginTop: '20px', // Add top margin for spacing from the text above
}}>
  <a href="https://is.gd/metromodoro" target="_blank" rel="noopener noreferrer">
    <button
      style={{
        backgroundColor: '#007bff',
        color: 'white',
        padding: '10px 20px',
        border: 'none',
        borderRadius: '5px',
        cursor: 'pointer',
      }}
    >
      MetroModoro Timer
    </button>
  </a>
  <a href="https://docs.google.com/spreadsheets/d/1HBUc-TEWy-jj0_9DLWEo2ZT7fpFMQmIh9pNgcKkq9qc/edit?usp=sharing" target="_blank" rel="noopener noreferrer">
    <button
      style={{
        backgroundColor: '#007bff',
        color: 'white',
        padding: '10px 20px',
        border: 'none',
        borderRadius: '5px',
        cursor: 'pointer',
      }}
    >
      Daily Tracker Spreadsheet
    </button>
  </a>
</div>

    </div>
  </div>
)}
  </div>
);};
  return (
    <div className="flex h-screen bg-gray-100 overflow-hidden">
      <Sidebar isOpen={isOpen} setIsOpen={setIsOpen} currentPage={currentPage} setCurrentPage={setCurrentPage} />
      <div className={`flex-1 ${isOpen ? 'ml-64' : 'ml-16'} transition-margin duration-300 ease-in-out p-10 text-2xl font-bold overflow-auto`}>
        {currentPage === 'MetroModoro' && <MetroModoro />}
        {currentPage === 'QID Extractor' && <QIDExtractor />}
      </div>
    </div>
  );
}